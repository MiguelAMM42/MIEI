<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble, embed[type="application/pdf"] {
    filter: invert(100%) hue-rotate(180deg) brightness(150%) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}</style><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #242729 !important;
}
html, body, input, textarea, select, button {
    background-color: #242729;
}
html, body, input, textarea, select, button {
    border-color: #838383;
    color: #ffffff;
}
a {
    color: #4ddaff;
}
table {
    border-color: #727272;
}
::placeholder {
    color: #ffffff;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #7e8900 !important;
    color: #ffffff !important;
}
::-webkit-scrollbar {
    background-color: #2a2d2f;
    color: #ffffff;
}
::-webkit-scrollbar-thumb {
    background-color: #474b4e;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #54595d;
}
::-webkit-scrollbar-thumb:active {
    background-color: #5c6065;
}
::-webkit-scrollbar-corner {
    background-color: #242729;
}
* {
    scrollbar-color: #2a2d2f #474b4e;
}
::selection {
    background-color: #008aff !important;
    color: #ffffff !important;
}
::-moz-selection {
    background-color: #008aff !important;
    color: #ffffff !important;
}</style><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #b97d00 !important;
    border-color: #ffff1c !important;
    color: #ffffff !important;
}
::placeholder {
    opacity: 0.5 !important;
}</style></head><body><h1 id="gui√£o-da-ficha-de-trabalho-4">Gui√£o da Ficha de Trabalho 4</h1>
<h2 id="introdu√ß√£o-aos-arrays">Introdu√ß√£o aos Arrays</h2>
<p>Os arrays encontram-se entre as estruturas de dados mais antigas e importantes em programa√ß√£o.</p>
<p>Em C, arrays s√£o uma fonte muito comum de erros ou falhas de 
seguran√ßa. Isto deve-se ao facto de estarem relacionados com o conceito
 de apontador de mem√≥ria, que tende a gerar alguma confus√£o. Um array 
corresponde a um conjunto de elementos, que se encontram armazenados num
 espa√ßo cont√≠guo em mem√≥ria.</p>
<p>Por exemplo, o array:</p>
<pre><code>int arr[5] = {10, 2, 13, 64, 7};</code></pre>
<p>Encontra-se representado em mem√≥ria da seguinte forma:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Endere√ßo</th>
<th style="text-align: center;">Valor</th>
<th style="text-align: center;">√çndice</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0x3bf4fbfd28</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0x3bf4fbfd2c</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x3bf4fbfd30</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">0x3bf4fbfd34</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x3bf4fbfd38</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p>Como tal, √© poss√≠vel aceder a um elemento de um array de tamanho N 
pelo seu √≠ndice, ou seja, a sua posi√ß√£o no array. Este √≠ndice 
come√ßa em 0 e termina em N-1.</p>
<p>Qualquer vari√°vel declarada como array √©, na verdade, <strong>um apontador para o primeiro elemento do array</strong>. Ou seja, a seguinte express√£o √© verdadeira (onde &amp; √© o operador refer√™ncia, ou seja ‚Äúendere√ßo de‚Äù):</p>
<pre><code>arr == &amp;arr[0]</code></pre>
<p>Isto tamb√©m permite o uso de <strong>aritm√©tica de apontadores</strong>, como por exemplo (onde * √© o operador de desrefer√™ncia):</p>
<pre><code>arr[2] == *(arr + 2);</code></pre>
<p>Isto nota-se tamb√©m no uso de <strong>char* para representar strings</strong>,
 que n√£o s√£o mais do que arrays de caracteres, e como tal, 
equivalentes a um apontador para o endere√ßo de mem√≥ria onde se situa o
 primeiro caracter da string.</p>
<pre><code>char *hello = "hello, world";</code></pre>
<p>√â equivalente a</p>
<pre><code>char hello[] = { 'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd' };</code></pre>
<p>Este acesso direto √&nbsp; mem√≥ria encontra-se mais presente em 
linguagens de mais baixo n√≠vel como C, ao contr√°rio de linguagens como
 Java ou C#, onde a gest√£o de mem√≥ria √© em grande parte feita 
automaticamente. Al√©m disso, confere uma grande vantagem de efici√™ncia
 a linguagens da fam√≠lia. Contudo, pode levar a riscos de <em>segmentation fault, stack overflow</em>, <em>heap corruption,</em> entre outros.</p>
<p><strong>Nota: no final deste gui√£o, s√£o introduzidos com mais detalhe os conceitos essenciais de arrays em C.</strong></p>
<h2 id="exerc√≠cios-propostos-para-praticar">Exerc√≠cios propostos para praticar</h2>
<ol type="1">
<li><p>Escreva um programa em C que seja capaz de efetuar a leitura de 
cinco n√∫mero inteiros para um array de 5 posi√ß√µes e de seguida os 
mostre pela ordem inversa da leitura.</p></li>
<li><p>Escreva um programa em C que, dado um array X de inteiros de N 
posi√ß√µes, transfere para um segundo array Y apenas os valores 
superiores √&nbsp; m√©dia dos valores em X.</p></li>
</ol>
<blockquote>
<p>Ex: dado X = {1, 8, 2, 5, 5}, deve colocar em Y os valores {8, 5, 5} (porque a m√©dia √© 4.2).</p>
</blockquote>
<ol type="1" start="3">
<li>Desenvolva uma <strong>fun√ß√£o</strong> em C que dadas duas strings
 verifica se a primeira cont√©m a segunda. Caso contenha, devolve o 
√≠ndice da 1¬∫ string onde o conte√∫do da 2¬∫ come√ßa. Caso contr√°rio, 
deve devolver -1.</li>
</ol>
<h2 id="tarefas-de-avalia√ß√£o">Tarefas de avalia√ß√£o</h2>
<p>Pretende-se que implemente em C as fun√ß√µes com os seguintes prot√≥tipos:</p>
<pre><code>void soma_elemento(int *arr, int dim, int idx);
void roda_esq(int *arr, int dim, int shifter);
int remove_menores(int *arr, int dim, int valor);</code></pre>
<ol type="1">
<li><p>Desenvolva uma <strong>fun√ß√£o</strong> em C que recebe um array
 de inteiros, a sua dimens√£o e um √≠ndice qualquer (menor que a 
dimens√£o). A fun√ß√£o dever√° alterar o array, onde cada elemento 
corresponde agora √&nbsp; sua soma com o valor no √≠ndice dado. Ex: dado
 {1, 5, 4, 3, 2}, a dimensao 5 e o √≠ndice 2, deve devolver: {5, 9, 8, 
7, 6}, que corresponde a {1+4, 5+4, 4+4, 3+4, 2+4}.</p></li>
<li><p>Desenvolva uma <strong>fun√ß√£o</strong> em C que recebe um array, a sua dimens√£o e ainda um <em>shifter</em>
 (qualquer inteiro maior ou igual a 0). A fun√ß√£o deve retornar o array
 com os seus elementos rodados para a esquerda. Ex: dado o array {1, 2, 
3, 4, 5}, a dimens√£o 5 e o shifter 3, deve devolver: {4, 5, 1, 2, 3}. 
Ex: dado o array {1, 2, 3, 4, 5}, a dimens√£o 5 e o shifter 7, deve 
devolver: {3, 4, 5, 1, 2}.</p></li>
<li><p>Desenvolva uma <strong>fun√ß√£o</strong> em C que dado um array, a
 sua dimens√£o e um valor, remova desse array os elementos menores do 
que o valor (movendo-os para o fim do array) e devolvendo o novo tamanho
 do array. Note que os valores mant√©m a sua ordem. Ex: dado o array {3,
 7, 2, 1, 4}, a dimens√£o 5 e o valor 4, deve devolver: {7, 4, 3, 2, 1}</p></li>
<li><p>Fa√ßa um programa principal que leia o n√∫mero da tarefa, a 
dimens√£o do array, os seus elementos e o √∫ltimo argumento e que 
imprima o array ap√≥s invocar a fun√ß√£o correspondente √&nbsp; tarefa.</p></li>
</ol>
<h2 id="conceitos-essenciais-de-arrays-em-c">Conceitos Essenciais de Arrays em C</h2>
<ul>
<li><p><strong>Declara√ß√£o de Arrays.</strong> Um array em C √© 
declarado, tal como uma vari√°vel normal, com o tipo e o nome. √â 
adicionada a capacidade do array, escrevendo o n√∫mero m√°ximo de 
elementos que esse array pode conter entre par√™ntesis retos ‚Äì [ e ].</p>
<ul>
<li><p><strong>int a[5];</strong></p></li>
<li><p><strong>int a[MAX];</strong> (usando #define MAX 5)</p></li>
<li><p><strong>int a[n];</strong> (se n foi previamente declarado)</p></li>
</ul></li>
<li><p><strong>Inicializa√ß√£o de Arrays.</strong> Um array pode ser 
inicializado com os valores em todas as suas posi√ß√µes de uma √∫nica 
vez. Para isso, usam-se chavetas - { e } - a rodear todo os elementos 
(cada um separado por v√≠rgulas).</p>
<ul>
<li><p><strong>int a[] = {12, 1, 32, 4, 6};</strong></p></li>
<li><p><strong>int a[3] = {12, 1, 32};</strong></p></li>
<li><p><strong>int a[10] = {12};</strong> //OK (as outras posi√ß√µes n√£o s√£o inicializadas)</p></li>
<li><p><strong>int a[2] = {12, 1, 32, 4};</strong></p>
<ul>
<li>Neste caso, o compilador vai mostrar um <strong>warning</strong>, pois √© declarado um array de 2 elementos e inicializado com 4.</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Notas:</p>
</blockquote>
<ul>
<li><p>Quando se declara e inicializa um array (ao mesmo tempo), n√£o √©
 necess√°rio indicar o seu tamanho (o compilador tratar√° disso).</p></li>
<li><p>Nada impede declarar um array numa instru√ß√£o e inici√°-lo noutra a seguir.</p></li>
<li><p><strong>Escrita em Arrays.</strong> Para atribuir um valor a uma 
posi√ß√£o no &gt; array, √© necess√°rio especificar o array e o √≠ndice 
da posi√ß√£o na &gt; qual queremos escrever. Aten√ß√£o que em C os 
√≠ndices dos arrays s√£o &gt; 0-based.</p>
<ul>
<li><p><strong>a[0] = 25;</strong></p></li>
<li><p><strong>a[10] = 11;</strong></p></li>
</ul></li>
</ul>
<!-- -->
<ul>
<li><p><strong>Leitura em Arrays.</strong> Para ler um valor num √≠ndice
 espec√≠fico √© necess√°rio especificar o array e qual o √≠ndice que 
queremos ler (novamente, os √≠ndices dos arrays s√£o 0-based).</p>
<ul>
<li><strong>int x = a[4];</strong></li>
</ul></li>
</ul>
<p><strong>Conceitos Essenciais de Mem√≥ria em C (foco em arrays)</strong></p>
<ul>
<li><p><strong>Disposi√ß√£o em mem√≥ria.</strong> A mem√≥ria pode ser 
vista como um bloco. Quando um array √© declarado, o compilador aloca a 
mem√≥ria necess√°ria para guardar todo o array.</p>
<ul>
<li>E.g., quando o array √© declarado como sendo array de 5 inteiros, ent√£o 5*4=20 bytes s√£o alocados na mem√≥ria.</li>
</ul></li>
<li><p><strong>Teoria de Apontadores (simplificada).</strong> A mem√≥ria
 pode ser vista como uma cidade. Cada bloco de mem√≥ria tem um endere√ßo
 √∫nico real, e nesse endere√ßo fica uma casa a que chamamos vari√°vel. 
Cada vari√°vel abriga um √∫nico inquilino, e portanto sabendo o nome da 
casa, saberemos quem a habita. Neste contexto, os arrays s√£o vistos 
como pr√©dios com um √∫nico apartamento por andar. Um √∫nico endere√ßo 
abriga mais do que um valor, e cada apartamento tem o seu endere√ßo 
√∫nico (e inquilino √∫nico). Assim, o primeiro inquilino mora no piso 0,
 o segundo mora no piso 1, etc.</p>
<ul>
<li><p>Por exemplo, vejamos o array <strong>a</strong> de 5 posi√ß√µes. Se queremos saber quem mora no piso N, basta verificar o endere√ßo do pr√©dio <strong>a</strong> e subir ao piso em quest√£o: a + N.</p>
<ul>
<li><strong>int a[5];</strong></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Declara um array de 5 inteiros (um pr√©dio de 5 apartamentos) com um endere√ßo √∫nico <strong>a</strong>. Assim, <strong>a+0=a</strong> √© o endere√ßo para o primeiro elemento do array, e <strong>a+3</strong> √© o endere√ßo para o 4¬∫ elemento do array.</p>
<p>O governo da cidade s√≥ conhece os endere√ßos reais, e n√£o o nome 
das casas nem quem as habita. Portanto, para saber quem vive onde, e 
onde alojar algu√©m, toma recurso a 2 servi√ßos importantes: o servi√ßo *
 e o servi√ßo &amp;.</p>
<p><strong>&amp;n</strong> fornece ao governo o endere√ßo real da casa <strong>n</strong>. <strong>*y</strong> fornece ao governo o habitante que habita no endere√ßo real y.</p>
<p>Para facilitar alguns processos, o governo usa apontadores, que n√£o 
s√£o mais do que nomes mais bonitos que apontam para endere√ßos reais. 
Todos os arrays s√£o para este governo apontadores.</p>
</blockquote>
<ul>
<li><p>a == &amp;a SIM Se a for um array ou um apontador.</p></li>
<li><p>*a == a[0] SIM Se a for um array ou um apontador.</p></li>
<li><p>a[i] == *(a+i) SIM</p></li>
<li><p>n == *(&amp;n) SIM</p></li>
<li><p>int *p o governo criou um apontador p para um endere√ßo qualquer.</p></li>
<li><p>p = x o apontador p aponta agora para o endere√ßo x</p></li>
<li><p>*p == *x SIM, o habitante no endere√ßo p e x √© o mesmo!</p></li>
</ul>
<!-- -->
<ul>
<li><strong>Array argumento de Fun√ß√£o</strong>. At√© agora, argumentos de fun√ß√µes s√£o passados por <strong>valor</strong>,
 isto √©, os argumentos de uma fun√ß√£o s√£o c√≥pias dos valores das 
vari√°veis. Isto √© uma boa pr√°tica quando as vari√°veis ocupam um 
espa√ßo pequeno em mem√≥ria.</li>
</ul>
<p>No entanto, os arrays podem ser grandes e copiar um array pode ser complexo. Assim, arrays s√£o sempre passados por <strong>refer√™ncia</strong>.
 Passar um argumento por refer√™ncia √© passar √&nbsp; fun√ß√£o o 
endere√ßo da vari√°vel. Deste modo, passa a existir um espa√ßo de 
mem√≥ria partilhada cujas altera√ß√µes dentro do contexto da fun√ß√£o 
ser√£o vistas exteriormente.</p>
<p>H√° v√°rias formas poss√≠veis de declarar uma fun√ß√£o que tem um array como par√¢metro:</p>
<pre><code>int func(int a[10]);
int func(int *a);
int func(int a[]);
int func(int a[], int size);
int func(int *a, int size);</code></pre>
<p>A duas √∫ltimas formas s√£o prefer√≠veis quando foi necess√°rio 
percorrer o array: o endere√ßo do array √© um par√¢metro e o seu tamanho
 √© outro. As outras formas podem ser utilizadas desde que n√£o se 
preciso de percorrer o array (ou haja alguma forma de saber quando 
acaba, como por exemplo no caso das strings que acabam com ‚Äò\0‚Äô).</p>
<h1 id="fun√ß√µes-que-devolvem-arrays">Fun√ß√µes que devolvem arrays</h1>
<pre><code>// Cen√°rio 1
int *func(...) {
    int a[10];
    ...
    return a;
}</code></pre>
<pre><code>// Cen√°rio 2
int *func(...) {
    int *a = (int *) malloc(tamanho * sizeof(int));
    ...
    return a;
}</code></pre>
<pre><code>// Cen√°rio 3
void func(int a[], int size) {
    ...
}</code></pre>
<p><strong>O primeiro cen√°rio √© errado!</strong> O compilador de C ir√° gerar um <strong>warning</strong>
 porque um endere√ßo de algo declarado dentro de uma fun√ß√£o est√° a 
ser retornado. Isto √© profundamente errado porque o array s√≥ <em>existe</em>
 enquanto estamos dentro da fun√ß√£o. Logo que sairmos da fun√ß√£o, o 
endere√ßo deixa de estar protegido e pode ser reutilizado por outras 
fun√ß√µes!</p>
<p>O segundo cen√°rio implica alocar primeiro o espa√ßo usando <strong>malloc</strong> e depois devolve o array que foi alocado.</p>
<p>No terceiro cen√°rio, a fun√ß√£o n√£o retorna nada, mas como o array 
foi passado por refer√™ncia, ele continua a existir assim que a fun√ß√£o
 termina (ao contr√°rio do primeiro caso). Relembrar que, como o array 
√© passado por refer√™ncia, qualquer altera√ß√£o dentro da fun√ß√£o 
ser√° vis√≠vel fora da fun√ß√£o.</p>
</body></html>